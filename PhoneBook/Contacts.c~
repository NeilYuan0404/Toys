#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define NAME_LENGTH 16
#define PHONE_LENGTH 32
#define BUFFER_LENGTH 128

#define INFO printf

//用宏来实现insert和remove功能
#define LIST_INSERT(item, list) do {		\
    item->prev = NULL;				\
    item->next = list;				\
    if ((list) != NULL) (list)->prev = item;	\
						\
    list = item;				\
  } while(0)					\

#define LIST_REMOVE(item, list) do {				\
    if (item->prev != NULL) item->prev->next = item->next;	\
    if (item->next != NULL) item->next->prev = item->prev;	\
    if (list == item) list = item->next;			\
    item->prev = item->next = NULL;				\
  } while(0)							\

//双向链表
struct person {
  char name[NAME_LENGTH];
  char phone[PHONE_LENGTH];

  struct person* next;
  struct person* prev;
};

struct contacts {
  struct person* people;
  int count;
};

enum {
  OPEN_INSERT = 1,
  OPEN_PRINT,
  OPEN_DELETE,
  OPEN_SEARCH,
  OPEN_SAVE,
  OPEN_LOAD
};

//接口层逻辑实现
int person_insert(struct person **ppeople, struct person *ps) {
  if (ps == NULL) return -1;
  if (ppeople == NULL) return -2;
  
  LIST_INSERT(ps, *ppeople);
  
  return 0;
}

int person_delete(struct person **ppeople, struct person *ps) {
  if (ps == NULL) return -1;
  
  LIST_REMOVE(ps, *ppeople);

  return 0;
}

struct person* person_search(struct person *people, const char *name) {
  
  struct person *item = NULL;
  for (item = people;item != NULL;item = item->next) {
    if (!strcmp(name, item->name))
      break;
  }
  return item;
}

int person_traversal(struct person *people) {
  struct person *item = NULL;
  for (item = people;item != NULL;item = item->next) {
    INFO("name: %s, phone: %s\n", item->name, item->phone);
  }
  return 0;
}

//这是高级功能的接口
int save_file(struct person *people, const char *filename) {
  FILE *fp = fopen(filename, "w");
  if (fp == NULL) return -1;

  struct person* item = NULL;
  for (item = people; item != NULL; item = item->next) {
    fprintf(fp, "姓名：%s, 号码：%s\n", item->name, item->phone);
    fflush(fp);
  }
  fclose(fp);
  return 0;
}

int parse_token(char *buffer, int length, char *name, char *phone) {
  if (buffer == NULL) return -1;
  if (length == 0) return -2;
  
  int i = 0, status = 0;
  int j = 0;
  for (i = 0; buffer[i] != ','; i++) {
    if (buffer[i] == ' ') {
      status = 0;
    } else if (status == 1) {
      name[j++] = buffer[i];
    }
  }

  status = 0;
  j = 0;
  for (; i < length; i++) {
    if (buffer[i] == ' ') {
      status = 1;
    } else if (status == 1) {
      phone[j++] = buffer[i];
    }
  }
  INFO("文件token:%s --> %s\n", name , phone);
  return 0;
}

int load_file(struct person *ppeople,int *count,  const char* filename) {
  FILE* fp = fopen(filename, "r");

  if (fp == NULL) return -1;

  while (!feof(fp)) {
    char buffer[BUFFER_LENGTH] = {0};
    fgets(buffer, BUFFER_LENGTH, fp);

    char name[NAME_LENGTH] = {0};
    char phone[PHONE_LENGTH] = {0};

    if (0 != parse_token(buffer, strlen(buffer), name, phone)) {
      continue;
    }

    struct person *p = (struct perosn*)malloc(sizeof(struct person));
    if (p == NULL) return -2;

    memcpy(p->name, name, NAME_LENGTH);
    memcpy(p->phone, phone, PHONE_LENGTH);

    person_insert(ppeople, p);

    (*count) ++;
  }
  
  return 0;
}
//结束高级功能接口逻辑
//结束接口层逻辑

////////////////////////////////////////////

//业务层逻辑 - 添加、删除、查找、遍历、保存通讯录、加载通讯录
//这是基础功能的业务逻辑
int insert_entry(struct contacts *cts) {
  if (cts == NULL) return -1;

  struct person *p = (struct person*)malloc(sizeof(struct person));
  if (p == NULL) return -2;

  INFO("请输入姓名：\n");
  scanf("%s", p->name);

  INFO("请输入号码：\n");
  scanf("%s", p->phone);

  if (0 != person_insert(&cts->people, p)) {
    free(p);
    return -3;
  }
  cts->count++;
  return 0;  
}

int print_entry(struct contacts *cts) {
  if (cts == NULL) return -1;
  
  person_traversal(cts->people);

  return 0;
}

int delete_entry(struct contacts *cts) {
  if (cts == NULL) return -1;

  INFO("请输入姓名：\n");
  char name[NAME_LENGTH] = {0};
  scanf("%s", name);
  struct person *ps = person_search(cts->people, name);
  if (ps == NULL) {
    INFO("不存在此人\n");
    return -2;
  }

  person_delete(&cts->people, ps);
  free(ps);

  return 0;
}

int search_entry(struct contacts *cts) {
  if (cts == NULL) return -1;

  INFO("请输入名字：\n");
  char name[NAME_LENGTH] = {0};
  scanf("%s", name);

  struct person *ps = person_search(cts->people, name);
  if (ps == NULL) {
    INFO("不存在此人\n");
    return -2;
  }

  INFO("姓名：%s,号码：%s\n", ps->name, ps->phone);

  return 0;
}


//TODO：高级功能：保存通讯录、加载通讯录
int save_entry(struct contacts *cts) {
  if (cts == NULL) return -1;

  INFO("请输入需要保存的通讯录名称:\n");
  char filename[NAME_LENGTH] = {0};
  scanf("%s", filename);

  save_file(cts->people, filename);
}

int load_entry(struct contacts *cts) {
  if (cts == NULL) return -1;

  INFO("请输入需要加载的通讯录名称:\n");
  char filename[NAME_LENGTH] = {0};
  scanf("%s", filename);

  load_file(&cts->people, &cts->count, filename);
}
//结束高级功能业务逻辑

void menu_info() {
  INFO("1.添加人员 2.打印人员 3.删除人员 4.搜索人员 \n功能测试中：5.保存通讯录 6.加载通讯录 Ctrl-C退出\n"); 
}


int main() {

  struct contacts *cts = malloc(sizeof(struct contacts));
  if (cts== NULL) return -1;

  memset(cts, 0, sizeof(struct contacts));
  
  while (1) {
    menu_info();
    int select = 0;
    scanf("%d", &select);

    switch (select) {
    case OPEN_INSERT:
      insert_entry(cts);
      break;
    case OPEN_PRINT:
      print_entry(cts);
      break;
    case OPEN_DELETE:
      delete_entry(cts);
      break;
    case OPEN_SEARCH:
      search_entry(cts);
      break;
    case OPEN_SAVE:
      save_entry(cts);
      break;
    case OPEN_LOAD:
      load_entry(cts);
      break;
    }

    
  }
}

